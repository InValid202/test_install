# © 2009 EduSense BV (<http://www.edusense.nl>)
# © 2011-2013 Therp BV (<https://therp.nl>)
# © 2016 Serv. Tecnol. Avanzados - Pedro M. Baeza
# © 2016 Akretion (Alexis de Lattre - alexis.delattre@akretion.com)
# License AGPL-3.0 or later (https://www.gnu.org/licenses/agpl.html).

import base64

from odoo import _, api, fields, models
from odoo.exceptions import UserError, ValidationError


class AccountPaymentOrder(models.Model):
    _name = "account.payment.order"
    _description = "Payment Order"
    _inherit = ["mail.thread"]
    _order = "id desc"
    _check_company_auto = True

    name = fields.Char(
        string="Number",
        readonly=True,
        copy=False,
        default='New',
    )
    partner_id = fields.Many2one(
        comodel_name='res.partner',
        string='Partner',
        readonly=True,
        states={"draft": [("readonly", False)]},
    )
    payment_mode_id = fields.Many2one(
        comodel_name="account.payment.mode",
        required=True,
        ondelete="restrict",
        tracking=True,
        readonly=True,
        states={"draft": [("readonly", False)]},
        check_company=True,
    )
    payment_type = fields.Selection(
        selection=[("inbound", "Inbound"), ("outbound", "Outbound")],
        readonly=True,
        required=True,
    )
    payment_method_id = fields.Many2one(
        comodel_name="account.payment.method",
        related="payment_mode_id.payment_method_id",
        readonly=True,
        store=True,
    )
    company_id = fields.Many2one(
        related="payment_mode_id.company_id", store=True, readonly=True
    )
    company_currency_id = fields.Many2one(
        related="payment_mode_id.company_id.currency_id", store=True, readonly=True
    )
    is_cheque = fields.Boolean(
        string='Is Cheque',
        related='payment_mode_id.is_cheque',
    )
    cheque_number = fields.Char(
        string='Cheque Number',
    )
    cheque_date = fields.Date(
        string='Cheque Date',
    )
    cheque_id = fields.Many2one(
        'account.cheque',
        string='Cheque',
        readonly=True,
        domain="[('state', '=','draft')]",
    )
    bank_id = fields.Many2one(
        comodel_name='res.bank',
        string='Bank',
    )
    cheque_ids = fields.Many2many(
        comodel_name='account.cheque',
        string='Cheques',
        domain="[('state', '=','draft')]",
    )
    bank_account_link = fields.Selection(
        related="payment_mode_id.bank_account_link", readonly=True
    )
    allowed_journal_ids = fields.Many2many(
        comodel_name="account.journal",
        compute="_compute_allowed_journal_ids",
        string="Allowed journals",
    )
    journal_id = fields.Many2one(
        comodel_name="account.journal",
        string="Bank Journal",
        ondelete="restrict",
        readonly=True,
        states={"draft": [("readonly", False)]},
        tracking=True,
        check_company=True,
    )
    # The journal_id field is only required at confirm step, to
    # allow auto-creation of payment order from invoice
    company_partner_bank_id = fields.Many2one(
        related="journal_id.bank_account_id",
        string="Company Bank Account",
        readonly=True,
    )
    state = fields.Selection(
        selection=[
            ("draft", "Draft"),
            ("open", "Confirmed"),
            ("generated", "File Generated"),
            ("uploaded", "File Uploaded"),
            ("cancel", "Cancel"),
        ],
        string="Status",
        readonly=True,
        copy=False,
        default="draft",
        tracking=True,
    )
    date_prefered = fields.Selection(
        selection=[
            ("now", "Immediately"),
            ("due", "Due Date"),
            ("fixed", "Fixed Date"),
        ],
        string="Payment Execution Date Type",
        required=True,
        default="fixed",
        tracking=True,
        readonly=True,
        states={"draft": [("readonly", False)]},
    )
    date_scheduled = fields.Date(
        string="Payment Execution Date",
        readonly=True,
        states={"draft": [("readonly", False)]},
        tracking=True,
        help="Select a requested date of execution if you selected 'Due Date' "
        "as the Payment Execution Date Type.",
    )
    date_generated = fields.Date(string="File Generation Date", readonly=True)
    date_uploaded = fields.Date(string="File Upload Date", readonly=True)
    generated_user_id = fields.Many2one(
        comodel_name="res.users",
        string="Generated by",
        readonly=True,
        ondelete="restrict",
        copy=False,
        check_company=True,
    )
    other_payment_line_ids = fields.One2many(
        comodel_name='account.payment.other.line',
        inverse_name='payment_id',
        string='Other Payment Line',
        readonly=True,
        states={"draft": [("readonly", False)]},
    )
    payment_line_ids = fields.One2many(
        comodel_name="account.payment.line",
        inverse_name="order_id",
        string="Transactions",
        readonly=True,
        states={"draft": [("readonly", False)]},
    )
    bank_line_ids = fields.One2many(
        comodel_name="bank.payment.line",
        inverse_name="order_id",
        string="Bank Transactions",
        readonly=True,
        help="The bank payment lines are used to generate the payment file. "
        "They are automatically created from transaction lines upon "
        "confirmation of the payment order: one bank payment line can "
        "group several transaction lines if the option "
        "'Group Transactions in Payment Orders' is active on the payment "
        "mode.",
    )
    total_company_currency = fields.Monetary(
        compute="_compute_total", store=True, currency_field="company_currency_id"
    )
    bank_line_count = fields.Integer(
        compute="_compute_bank_line_count", string="Number of Bank Transactions"
    )
    move_ids = fields.One2many(
        comodel_name="account.move",
        inverse_name="payment_order_id",
        string="Journal Entries",
        readonly=True,
    )
    move_count = fields.Integer(
        compute="_compute_move_count", string="Number of Journal Entries"
    )
    description = fields.Char()
    amount = fields.Float(
        string='Other Amount',
        compute='_compute_amount',
    )
    invoice_total = fields.Float(
        compute = '_compute_invoice',
        string = 'Amount Invoice Total'
    )
    total_amount = fields.Float(
        string='Total Amount',
        compute='_compute_total_amount',
    )

    @api.depends('invoice_total', 'amount')
    def _compute_total_amount(self):
        """docstring for _compute_total_amount"""
        for rec in self:
            rec.total_amount = rec.invoice_total + rec.amount

    @api.depends('payment_line_ids.amount_company_currency')
    def _compute_invoice(self):
        payment = self
        payment.invoice_total = sum(line.amount_company_currency for line in payment.payment_line_ids)
#         payment.wht_total = sum(line.paid_total for line in payment.payment_line if line.wht_id)

    @api.depends('other_payment_line_ids.paid_total')
    def _compute_amount(self):
        for rec in self:
            rec.amount = 0
            for payment in rec.other_payment_line_ids:
                rec.amount += payment.paid_total

    @api.depends("payment_mode_id")
    def _compute_allowed_journal_ids(self):
        for record in self:
            if record.payment_mode_id.bank_account_link == "fixed":
                record.allowed_journal_ids = record.payment_mode_id.fixed_journal_id
            elif record.payment_mode_id.bank_account_link == "variable":
                record.allowed_journal_ids = record.payment_mode_id.variable_journal_ids
            else:
                record.allowed_journal_ids = False

    @api.onchange('payment_type')
    def onchange_payment_type(self):
        """docstring for onchange_payment_type"""
        for rec in self:
            mode = self.env['account.payment.mode'].search([('payment_type', '=', rec.payment_type),('is_default', '=', True)])
            if mode:
                rec.payment_mode_id = mode.id

    @api.onchange('partner_id')
    def onchange_partner_id(self):
        """docstring for onchange"""
        line_list = []
        if self.partner_id:
            AM = self.env['account.move']
            domain = [
                ('partner_id', '=', self.partner_id.id),
                ('state', '=', 'posted'),
            ]
            if self.payment_type == 'outbound':
                domain.append(('move_type', 'in', ('in_invoice', 'in_refund')))
            else:
                domain.append(('move_type', 'in', ('out_invoice', 'out_refund')))
            move_search = AM.search(domain)
            for move in move_search:
                applicable_lines = move.line_ids.filtered(
                    lambda x: (
                        not x.reconciled
                        and x.account_id.account_type in ("asset_receivable", "liability_payable")
                        and not any(
                            p_state in ("draft", "open", "generated")
                            for p_state in x.payment_line_ids.mapped("state")
                        )
                    )
                )
                if not applicable_lines:
                    continue
                payment_type = self.payment_type
                for line in applicable_lines:
                    vals_line = line._prepare_payment_line_onchange_vals(payment_type)
                    vals_line['communication_type'] = 'normal'
                    vals_line['communication'] = move.name
                    line_list.append((0, 0,vals_line))
        self.payment_line_ids = line_list

    def unlink(self):
        for order in self:
            if order.state == "uploaded":
                raise UserError(
                    _(
                        "You cannot delete an uploaded payment order. You can "
                        "cancel it in order to do so."
                    )
                )
        return super(AccountPaymentOrder, self).unlink()

    @api.constrains("payment_type", "payment_mode_id")
    def payment_order_constraints(self):
        for order in self:
            if (
                order.payment_mode_id.payment_type
                and order.payment_mode_id.payment_type != order.payment_type
            ):
                raise ValidationError(
                    _(
                        "The payment type (%(ptype)s) is not the same as the payment "
                        "type of the payment mode (%(pmode)s)",
                        ptype=order.payment_type,
                        pmode=order.payment_mode_id.payment_type,
                    )
                )

    @api.constrains("date_scheduled")
    def check_date_scheduled(self):
        return True
        today = fields.Date.context_today(self)
        for order in self:
            if order.date_scheduled:
                if order.date_scheduled < today:
                    raise ValidationError(
                        _(
                            "On payment order %(porder)s, the Payment Execution Date "
                            "is in the past (%(exedate)s).",
                            porder=order.name,
                            exedate=order.date_scheduled,
                        )
                    )

    @api.depends("payment_line_ids", "payment_line_ids.amount_company_currency")
    def _compute_total(self):
        for rec in self:
            rec.total_company_currency = sum(
                rec.mapped("payment_line_ids.amount_company_currency") or [0.0]
            )

    @api.depends("bank_line_ids")
    def _compute_bank_line_count(self):
        for order in self:
            order.bank_line_count = len(order.bank_line_ids)

    @api.depends("move_ids")
    def _compute_move_count(self):
        rg_res = self.env["account.move"].read_group(
            [("payment_order_id", "in", self.ids)],
            ["payment_order_id"],
            ["payment_order_id"],
        )
        mapped_data = {
            x["payment_order_id"][0]: x["payment_order_id_count"] for x in rg_res
        }
        for order in self:
            order.move_count = mapped_data.get(order.id, 0)

    @api.model
    def create(self, vals):
#         if vals.get("name", "New") == "New":
#             if 'payment_type' in vals and vals.get('payment_type') == 'outbound':
#                 name = self.env["ir.sequence"].next_by_code("account.payment.order")
#             elif vals.get('payment_type') == 'outbound':
#                 name = self.env["ir.sequence"].next_by_code("account.debit.order")
#             vals["name"] = name
        if vals.get("payment_mode_id"):
            payment_mode = self.env["account.payment.mode"].browse(
                vals["payment_mode_id"]
            )
            vals["payment_type"] = payment_mode.payment_type
            if payment_mode.bank_account_link == "fixed":
                vals["journal_id"] = payment_mode.fixed_journal_id.id
            if not vals.get("date_prefered") and payment_mode.default_date_prefered:
                vals["date_prefered"] = payment_mode.default_date_prefered
        return super(AccountPaymentOrder, self).create(vals)

    @api.onchange("payment_mode_id")
    def payment_mode_id_change(self):
        if len(self.allowed_journal_ids) == 1:
            self.journal_id = self.allowed_journal_ids
        if self.payment_mode_id.default_date_prefered:
            self.date_prefered = self.payment_mode_id.default_date_prefered

    def action_uploaded_cancel(self):
        for move in self.move_ids:
            move.button_cancel()
            for move_line in move.line_ids:
                move_line.remove_move_reconcile()
            move.with_context(force_delete=True).unlink()
        self.action_cancel()
        return True

    def cancel2draft(self):
        self.write({"state": "draft"})
        for order in self:
            for line in order.other_payment_line_ids:
                if line.wht_id:
                    line.wht_id.update({'state': 'draft'})
        return True

    def action_cancel(self):
        for move in self.move_ids:
            move.button_cancel()
            for move_line in move.line_ids:
                move_line.remove_move_reconcile()
            move.with_context(force_delete=True).unlink()
        for order in self:
            order.write({"state": "cancel"})
            order.bank_line_ids.unlink()
            for line in order.other_payment_line_ids:
                if line.wht_id:
                    line.wht_id.update({'state': 'cancel'})
        return True

    @api.model
    def _prepare_bank_payment_line(self, paylines):
        return {
            "order_id": paylines[0].order_id.id,
            "payment_line_ids": [(6, 0, paylines.ids)],
            "communication": "-".join([line.communication for line in paylines]),
        }

    def draft2open(self):
        """
        Called when you click on the 'Confirm' button
        Set the 'date' on payment line depending on the 'date_prefered'
        setting of the payment.order
        Re-generate the bank payment lines
        """
        bplo = self.env["bank.payment.line"]
        today = fields.Date.context_today(self)
        for order in self:
            if not order.journal_id:
                raise UserError(
                    _("Missing Bank Journal on payment order %s.") % order.name
                )
            if (
                order.payment_method_id.bank_account_required
                and not order.journal_id.bank_account_id
            ):
                raise UserError(
                    _("Missing bank account on bank journal '%s'.")
                    % order.journal_id.display_name
                )
            if not order.payment_line_ids:
                raise UserError(
                    _("There are no transactions on payment order %s.") % order.name
                )
            # Delete existing bank payment lines
            order.bank_line_ids.unlink()
            # Create the bank payment lines from the payment lines
            group_paylines = {}  # key = hashcode
            for payline in order.payment_line_ids:
                payline.draft2open_payment_line_check()
                # Compute requested payment date
                if order.date_prefered == "due":
                    requested_date = payline.ml_maturity_date or payline.date or today
                elif order.date_prefered == "fixed":
                    requested_date = order.date_scheduled or today
                else:
                    requested_date = today
                # No payment date in the past
                if requested_date < today:
                    requested_date = today
                # inbound: check option no_debit_before_maturity
                if (
                    order.payment_type == "inbound"
                    and order.payment_mode_id.no_debit_before_maturity
                    and payline.ml_maturity_date
                    and requested_date < payline.ml_maturity_date
                ):
                    raise UserError(
                        _(
                            "The payment mode '%(pmode)s' has the option "
                            "'Disallow Debit Before Maturity Date'. The "
                            "payment line %(pline)s has a maturity date %(mdate)s "
                            "which is after the computed payment date %(pdate)s.",
                            pmode=order.payment_mode_id.name,
                            pline=payline.name,
                            mdate=payline.ml_maturity_date,
                            pdate=requested_date,
                        )
                    )
                # Write requested_date on 'date' field of payment line
                # norecompute is for avoiding a chained recomputation
                # payment_line_ids.date
                # > payment_line_ids.amount_company_currency
                # > total_company_currency
                with self.env.norecompute():
                    payline.date = requested_date
                # Group options
                if order.payment_mode_id.group_lines:
                    hashcode = payline.payment_line_hashcode()
                else:
                    # Use line ID as hascode, which actually means no grouping
                    hashcode = payline.id
                if hashcode in group_paylines:
                    group_paylines[hashcode]["paylines"] += payline
                    group_paylines[hashcode]["total"] += payline.amount_currency
                else:
                    group_paylines[hashcode] = {
                        "paylines": payline,
                        "total": payline.amount_currency,
                    }
            order.recompute()
            # Create bank payment lines
            for paydict in list(group_paylines.values()):
                # Block if a bank payment line is <= 0
                if paydict["total"] <= 0:
                    raise UserError(
                        _(
                            "The amount for Partner '%(partner)s' is negative "
                            "or null (%(amount).2f) !",
                            partner=paydict["paylines"][0].partner_id.name,
                            amount=paydict["total"],
                        )
                    )
                vals = self._prepare_bank_payment_line(paydict["paylines"])
                bplo.create(vals)
        self.write({"state": "open"})
        if self.payment_type == 'inbound':
            self.open2generated()
            self.generated2uploaded()
        if self.name == 'New':
            if self.payment_type == 'outbound':
                name = self.env["ir.sequence"].with_context(ir_sequence_date=self.date_scheduled).next_by_code("account.payment.order")
            elif self.payment_type == 'inbound':
                name = self.env["ir.sequence"].with_context(ir_sequence_date=self.date_scheduled).next_by_code("account.debit.order")
            self.write({"name": name})
        return True

    def generate_payment_file(self):
        """Returns (payment file as string, filename)"""
        self.ensure_one()
        if self.payment_method_id.code == "manual":
            return (False, False)
        else:
            raise UserError(
                _(
                    "No handler for this payment method. Maybe you haven't "
                    "installed the related Odoo module."
                )
            )

    def open2generated(self):
        self.ensure_one()
        payment_file_str, filename = self.generate_payment_file()
        for order in self:
            if order.payment_mode_id.generate_move:
                order.generate_move()
        action = {}
        if payment_file_str and filename:
            attachment = self.env["ir.attachment"].create(
                {
                    "res_model": "account.payment.order",
                    "res_id": self.id,
                    "name": filename,
                    "datas": base64.b64encode(payment_file_str),
                }
            )
            simplified_form_view = self.env.ref(
                "account_payment_order.view_attachment_simplified_form"
            )
            action = {
                "name": _("Payment File"),
                "view_mode": "form",
                "view_id": simplified_form_view.id,
                "res_model": "ir.attachment",
                "type": "ir.actions.act_window",
                "target": "current",
                "res_id": attachment.id,
            }
        self.write(
            {
                "date_generated": self.date_scheduled,
                "state": "generated",
                "generated_user_id": self._uid,
            }
        )
        return action

    def generated2uploaded(self):
        for order in self:
            if order.is_cheque and not order.cheque_id:
                order.create_cheque()
            moves = self.env["account.move"].search([("payment_order_id", "=", order.id)])
            post_move = order.payment_mode_id.post_move
            if post_move:
                for move in moves:
                    if move.state == 'draft':
                        move.action_post()
        self.write(
            {"state": "uploaded", "date_uploaded": fields.Date.context_today(self)}
        )
        return True

    def _prepare_move(self, bank_lines=None):
        if self.payment_type == "outbound":
            ref = _("Payment order %s") % self.name
        else:
            ref = _("Debit order %s") % self.name
        if bank_lines and len(bank_lines) == 1:
            ref += " - " + bank_lines.name
        vals = {
#             "date": bank_lines[0].date,
            "date": self.date_scheduled,
            "journal_id": self.journal_id.id,
            "ref": ref,
            "payment_order_id": self.id,
            "payment_type": self.payment_type,
            'narration': self.description,
            "line_ids": [],
        }
        total_company_currency = total_payment_currency = 0
        for bline in bank_lines:
            total_company_currency += bline.amount_company_currency
            total_payment_currency += bline.amount_currency
            partner_ml_vals = self._prepare_move_line_partner_account(bline)
            vals["line_ids"].append((0, 0, partner_ml_vals))
        for oline in self.other_payment_line_ids:
            total_company_currency += oline.paid_total
            total_payment_currency += oline.paid_total
            other_ml_vals = self._prepare_move_line_other_account(oline)
            vals["line_ids"].append((0, 0, other_ml_vals))
        if total_payment_currency != 0:
            trf_ml_vals = self._prepare_move_line_offsetting_account(
                total_company_currency, total_payment_currency, bank_lines
            )
            vals["line_ids"].append((0, 0, trf_ml_vals))
        return vals

    def _prepare_move_line_offsetting_account(
        self, amount_company_currency, amount_payment_currency, bank_lines
    ):
        vals = {}
        payment_method = self.payment_mode_id.payment_method_id
        account_id = False
        if self.payment_type == "inbound":
            account_id = (
                self.journal_id.inbound_payment_method_line_ids.filtered(
                    lambda x: x.payment_method_id == payment_method
                ).payment_account_id.id
                or self.journal_id.company_id.account_journal_payment_debit_account_id.id
            )
        elif self.payment_type == "outbound":
            account_id = (
                self.journal_id.outbound_payment_method_line_ids.filtered(
                    lambda x: x.payment_method_id == payment_method
                ).payment_account_id.id
                or self.journal_id.company_id.account_journal_payment_credit_account_id.id
            )

        partner_id = False
        for index, bank_line in enumerate(bank_lines):
            if index == 0:
                partner_id = bank_line.payment_line_ids[0].partner_id.id
            elif bank_line.payment_line_ids[0].partner_id.id != partner_id:
                # we have different partners in the grouped move
                partner_id = False
                break
        if self.cheque_number:
            name = "Cheque Number: %s" % self.cheque_number
        else:
            name = ''
        vals.update(
            {
                "name": name,
                "partner_id": partner_id,
                "account_id": account_id,
                "credit": (
                    self.payment_type == "outbound" and amount_company_currency or 0.0
                ),
                "debit": (
                    self.payment_type == "inbound" and amount_company_currency or 0.0
                ),
            }
        )
        if bank_lines[0].currency_id != bank_lines[0].company_currency_id:
            sign = self.payment_type == "outbound" and -1 or 1
            vals.update(
                {
                    "currency_id": bank_lines[0].currency_id.id,
                    "amount_currency": amount_payment_currency * sign,
                }
            )
        return vals

    def _prepare_move_line_partner_account(self, bank_line):
        if bank_line.payment_line_ids[0].move_line_id:
            account_id = bank_line.payment_line_ids[0].move_line_id.account_id.id
        else:
            if self.payment_type == "inbound":
                account_id = bank_line.partner_id.property_account_receivable_id.id
            else:
                account_id = bank_line.partner_id.property_account_payable_id.id
        if self.payment_type == "outbound":
            name = _("Payment bank line %s") % bank_line.name
        else:
            name = _("Debit bank line %s") % bank_line.name
        vals = {
            "name": name,
            "bank_payment_line_id": bank_line.id,
            "partner_id": bank_line.partner_id.id,
            "account_id": account_id,
            "credit": (
                self.payment_type == "inbound"
                and bank_line.amount_company_currency
                or 0.0
            ),
            "debit": (
                self.payment_type == "outbound"
                and bank_line.amount_company_currency
                or 0.0
            ),
        }

        if bank_line.currency_id != bank_line.company_currency_id:
            sign = self.payment_type == "inbound" and -1 or 1
            vals.update(
                {
                    "currency_id": bank_line.currency_id.id,
                    "amount_currency": bank_line.amount_currency * sign,
                }
            )
        return vals

    def _prepare_move_line_other_account(self, o_line):
        method = o_line.payment_method_id
        name = _("Other line: %s") % o_line.payment_method_id.name
        if o_line.label:
            name += ' - ' + o_line.label
        account_id = method.account_id.id
        if self.payment_type == "outbound":
            debit = o_line.paid_total if o_line.paid_total > 0 else 0
            credit = abs(o_line.paid_total) if o_line.paid_total < 0 else 0
        else:
            credit = o_line.paid_total if o_line.paid_total > 0 else 0
            debit = abs(o_line.paid_total) if o_line.paid_total < 0 else 0
        vals = {
            "name": name,
            "partner_id": self.partner_id.id,
            "account_id": account_id,
            "credit": credit,
            "debit": debit,
        }
        return vals

    def _create_reconcile_move(self, hashcode, blines):
        self.ensure_one()
        post_move = self.payment_mode_id.post_move
        am_obj = self.env["account.move"]
        mvals = self._prepare_move(blines)
        move = am_obj.create(mvals)
        if post_move:
            move.action_post()
        if self.payment_mode_id.reconcile:
            blines.reconcile_payment_lines()

    def _prepare_trf_moves(self):
        """
        prepare a dict "trfmoves" that can be used when
        self.payment_mode_id.move_option = date or line
        key = unique identifier (date or True or line.id)
        value = bank_pay_lines (recordset that can have several entries)
        """
        self.ensure_one()
        trfmoves = {}
        for bline in self.bank_line_ids:
            hashcode = bline.move_line_offsetting_account_hashcode()
            if hashcode in trfmoves:
                trfmoves[hashcode] += bline
            else:
                trfmoves[hashcode] = bline
        return trfmoves

    def generate_move(self):
        """
        Create the moves that pay off the move lines from
        the payment/debit order.
        """
        self.ensure_one()
        trfmoves = self._prepare_trf_moves()
        for hashcode, blines in trfmoves.items():
            self._create_reconcile_move(hashcode, blines)

    def get_cheque_payment(self):
        """docstring for get_cheque_payment"""
        if not self.cheque_number:
            raise UserError(_('Please insert Cheque number'))
        if self.cheque_number:
            cheq = self.env['account.cheque'].search([('name', '=', self.cheque_number)])
            if cheq:
                self.cheque_id = cheq.id
            else:
                raise UserError(_('No Cheque number, Please create Cheque'))

    def create_cheque(self):
        if self.total_amount <= 0:
            raise UserError(_('Total Payment Method Not Less more Zero.'))
#         if self.cheque_id:
#             raise UserError(_('You have cheque alredy!'))
#         if not self.bank_id:
#             raise except_orm(_('No Bank!'), _('Please insert bank'))

        if not self.cheque_number:
            raise UserError(_('Please insert Cheque number'))
        if not self.cheque_date:
            raise UserError(_('Please insert date   '))
        if self.payment_type == 'inbound':
            cheque_type = 'in'
            if not self.payment_mode_id.cheque_income_account_id:
                raise UserError(_('Please insert Cheque Income Account'))
            account_id = self.payment_mode_id.cheque_income_account_id.id

        else:
            cheque_type = 'out'
            if not self.payment_mode_id.cheque_out_account_id:
                raise UserError(_('Please insert Cheque Out Account'))
            account_id = self.payment_mode_id.cheque_out_account_id.id
        comp = self.company_id
        cheq = self.env['account.cheque'].search([('name', '=', self.cheque_number),('company_id', '=', comp.id),('state', 'not in', ('cancel', 'reject'))])
        if cheq and not self.cheque_id:
            self.cheque_id = cheq[0].id
            self.update({'cheque_ids': [(6, 0, cheq.ids)]})
        else:
            cheque_vals = {
                    'name': self.cheque_number,
                    'bank': self.bank_id.id if self.bank_id else 'None',
                    'cheque_date': self.cheque_date,
                    'partner_id': self.partner_id.id if self.partner_id else self.payment_line_ids[0].partner_id.id,
                    'journal_id': self.journal_id.id,
                    'amount': self.total_amount,
                    'type': cheque_type,
                    'account_receipt_id': account_id,
                    'account_pay_id': account_id,
                    'payment_order_id' :self.id,
                    'payment_mode_id': self.payment_mode_id.id,
                }
            cheque_id = self.env['account.cheque'].create(cheque_vals)
            self.cheque_id = cheque_id
            self.update({'cheque_ids': [(6, 0, cheque_id.ids)]})

    def action_bank_payment_line(self):
        self.ensure_one()
        action = self.sudo().env.ref("account_payment_order.bank_payment_line_action")
        action_dict = action.read()[0]
        action_dict["domain"] = [("id", "in", self.bank_line_ids.ids)]
        return action_dict

    def action_move_journal_line(self):
        self.ensure_one()
        action = self.env.ref("account.action_move_journal_line").sudo().read()[0]
        if self.move_count == 1:
            action.update(
                {
                    "view_mode": "form,tree,kanban",
                    "views": False,
                    "view_id": False,
                    "res_id": self.move_ids[0].id,
                }
            )
        else:
            action["domain"] = [("id", "in", self.move_ids.ids)]
        ctx = self.env.context.copy()
        ctx.update({"search_default_misc_filter": 0})
        action["context"] = ctx
        return action

    def clear_line(self):
        """docstring for clear_line"""
        for rec in self:
            for line in rec.payment_line_ids:
                line.unlink()
